// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crds.yaml

package v1

import (
	"strings"
	"list"
)

// DNSPolicy is the Schema for the dnspolicies API
#DNSPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "kuadrant.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "DNSPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// DNSPolicySpec defines the desired state of DNSPolicy
	spec!: #DNSPolicySpec
}

// DNSPolicySpec defines the desired state of DNSPolicy
#DNSPolicySpec: {
	// ExcludeAddresses is a list of addresses (either hostnames, CIDR
	// or IPAddresses) that DNSPolicy should not use as values in the
	// configured DNS provider records. The default is to allow all
	// addresses configured in the Gateway DNSPolicy is targeting
	excludeAddresses?: list.MaxItems(20) & [...string]

	// HealthCheckSpec configures health checks in the DNS provider.
	// By default this health check will be applied to each unique DNS
	// A Record for
	// the listeners assigned to the target gateway
	healthCheck?: {
		additionalHeadersRef?: {
			name: string
		}

		// FailureThreshold is a limit of consecutive failures that must
		// occur for a host to be considered unhealthy
		// Defaults to 5
		failureThreshold?: int | *5

		// Interval defines how frequently this probe should execute
		// Defaults to 5 minutes
		interval?: string | *"5m"

		// Path is the path to append to the host to reach the expected
		// health check.
		// Must start with "?" or "/", contain only valid URL characters
		// and end with alphanumeric char or "/". For example "/" or
		// "/healthz" are common
		path?: =~"^(?:\\?|\\/)[\\w\\-.~:\\/?#\\[\\]@!$&'()*+,;=]+(?:[a-zA-Z0-9]|\\/){1}$"

		// Port to connect to the host on. Must be either 80, 443 or
		// 1024-49151
		// Defaults to port 443
		port?: int | *443

		// Protocol to use when connecting to the host, valid values are
		// "HTTP" or "HTTPS"
		// Defaults to HTTPS
		protocol?: string | *"HTTPS"
	}
	loadBalancing?: {
		// defaultGeo specifies if this is the default geo for providers
		// that support setting a default catch all geo endpoint such as
		// Route53.
		defaultGeo: bool

		// geo value to apply to geo endpoints.
		//
		// The values accepted are determined by the target dns provider,
		// please refer to the appropriate docs below.
		//
		// Route53:
		// https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html
		// Google: https://cloud.google.com/compute/docs/regions-zones
		// Azure:
		// https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions
		geo: strings.MinRunes(2)

		// weight value to apply to weighted endpoints.
		//
		// The maximum value accepted is determined by the target dns
		// provider, please refer to the appropriate docs below.
		//
		// Route53:
		// https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-weighted.html
		// Google: https://cloud.google.com/dns/docs/overview/
		// Azure:
		// https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-routing-methods#weighted-traffic-routing-method
		weight: int | *120
	}

	// providerRefs is a list of references to provider secrets. Max
	// is one but intention is to allow this to be more in the future
	providerRefs: list.MaxItems(1) & [...{
		name: strings.MinRunes(1)
	}] & [_, ...]

	// targetRef identifies an API object to apply policy to.
	targetRef: {
		// Group is the group of the target resource.
		group: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}
}
