// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crds.yaml

package v1

import "strings"

// RateLimitPolicy enables rate limiting for service workloads in
// a Gateway API network
#RateLimitPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "kuadrant.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "RateLimitPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}
	spec!: #RateLimitPolicySpec
}
#RateLimitPolicySpec: {
	// Rules to apply as defaults. Can be overridden by more specific
	// policiy rules lower in the hierarchy and by less specific
	// policy overrides.
	// Use one of: defaults, overrides, or bare set of policy rules
	// (implicit defaults).
	defaults?: {
		// Limits holds the struct of limits indexed by a unique name
		limits?: {
			[string]: {
				// Counters defines additional rate limit counters based on CEL
				// expressions which can reference well known selectors
				counters?: [...{
					// Expression defines one CEL expression
					// Expression can use well known attributes
					// Attributes:
					// https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
					// Well-known selectors:
					// https://github.com/Kuadrant/architecture/blob/main/rfcs/0001-rlp-v2.md#well-known-selectors
					// They are named by a dot-separated path (e.g. request.path)
					// Example: "request.path" -> The path portion of the URL
					expression: strings.MinRunes(1)
				}]

				// Rates holds the list of limit rates
				rates?: [...{
					// Limit defines the max value allowed for a given period of time
					limit: int

					// Window defines the time period for which the Limit specified
					// above applies.
					window: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
				}]

				// When holds a list of "limit-level" `Predicate`s
				// Called also "soft" conditions as route selectors must also
				// match
				when?: [...{
					predicate: strings.MinRunes(1)
				}]
			}
		}

		// Strategy defines the merge strategy to apply when merging this
		// policy with other policies.
		strategy?: "atomic" | "merge" | *"atomic"

		// Overall conditions for the policy to be enforced.
		// If omitted, the policy will be enforced at all requests to the
		// protected routes.
		// If present, all conditions must match for the policy to be
		// enforced.
		when?: [...{
			predicate: strings.MinRunes(1)
		}]
	}

	// Limits holds the struct of limits indexed by a unique name
	limits?: {
		[string]: {
			// Counters defines additional rate limit counters based on CEL
			// expressions which can reference well known selectors
			counters?: [...{
				// Expression defines one CEL expression
				// Expression can use well known attributes
				// Attributes:
				// https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
				// Well-known selectors:
				// https://github.com/Kuadrant/architecture/blob/main/rfcs/0001-rlp-v2.md#well-known-selectors
				// They are named by a dot-separated path (e.g. request.path)
				// Example: "request.path" -> The path portion of the URL
				expression: strings.MinRunes(1)
			}]

			// Rates holds the list of limit rates
			rates?: [...{
				// Limit defines the max value allowed for a given period of time
				limit: int

				// Window defines the time period for which the Limit specified
				// above applies.
				window: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
			}]

			// When holds a list of "limit-level" `Predicate`s
			// Called also "soft" conditions as route selectors must also
			// match
			when?: [...{
				predicate: strings.MinRunes(1)
			}]
		}
	}

	// Rules to apply as overrides. Override all policy rules lower in
	// the hierarchy. Can be overridden by less specific policy
	// overrides.
	// Use one of: defaults, overrides, or bare set of policy rules
	// (implicit defaults).
	overrides?: {
		// Limits holds the struct of limits indexed by a unique name
		limits?: {
			[string]: {
				// Counters defines additional rate limit counters based on CEL
				// expressions which can reference well known selectors
				counters?: [...{
					// Expression defines one CEL expression
					// Expression can use well known attributes
					// Attributes:
					// https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
					// Well-known selectors:
					// https://github.com/Kuadrant/architecture/blob/main/rfcs/0001-rlp-v2.md#well-known-selectors
					// They are named by a dot-separated path (e.g. request.path)
					// Example: "request.path" -> The path portion of the URL
					expression: strings.MinRunes(1)
				}]

				// Rates holds the list of limit rates
				rates?: [...{
					// Limit defines the max value allowed for a given period of time
					limit: int

					// Window defines the time period for which the Limit specified
					// above applies.
					window: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
				}]

				// When holds a list of "limit-level" `Predicate`s
				// Called also "soft" conditions as route selectors must also
				// match
				when?: [...{
					predicate: strings.MinRunes(1)
				}]
			}
		}

		// Strategy defines the merge strategy to apply when merging this
		// policy with other policies.
		strategy?: "atomic" | "merge" | *"atomic"

		// Overall conditions for the policy to be enforced.
		// If omitted, the policy will be enforced at all requests to the
		// protected routes.
		// If present, all conditions must match for the policy to be
		// enforced.
		when?: [...{
			predicate: strings.MinRunes(1)
		}]
	}

	// Reference to the object to which this policy applies.
	targetRef: {
		// Group is the group of the target resource.
		group: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// Overall conditions for the policy to be enforced.
	// If omitted, the policy will be enforced at all requests to the
	// protected routes.
	// If present, all conditions must match for the policy to be
	// enforced.
	when?: [...{
		predicate: strings.MinRunes(1)
	}]
}
